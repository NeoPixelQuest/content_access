<?php
// $Id$

/**
 * @file Content access module file.
 */


/**
 * Implementation of hook_menu().
 */
function content_access_menu() {
  $items = array();

  $items['node/%node/access'] = array(
    'title' => 'Access control',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('content_access_page', 1),
    'access callback' => 'content_access_node_page_access',
    'access arguments' => array(1),
    'file' => 'content_access.admin.inc',
    'weight' => 5,
    'type' => MENU_LOCAL_TASK
  );

  foreach (node_get_types('types', NULL, TRUE) as $type) {
    $type_url_str = str_replace('_', '-', $type->type);
    $items['admin/content/node-type/'. $type_url_str .'/access'] = array(
      'title' => t('Access control'),
      'description' => t('Configure content access control.'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('content_access_admin_settings', $type->type),
      'access callback' => 'content_access_admin_settings_access',
      'access arguments' => array(),
      'type' => MENU_LOCAL_TASK,
      'file' => 'content_access.admin.inc',
      'weight' => 2,
    );
  }
  return $items;
}

function content_access_node_page_access($node) {
  global $user;
  return content_access_get_settings('per_node', $node->type) && user_access('grant content access') || content_access_get_settings('per_node', $node->type) && (user_access('grant own content access') && ($user->uid == $node->uid));
}

function content_access_admin_settings_access() {
  return user_access('administer nodes') && user_access('administer content types');
}

/**
 * Implementation of hook_perm().
 */
function content_access_perm() {
  return array('grant content access', 'grant own content access');
}

/**
 * Implementation of hook_node_grants().
 */
function content_access_node_grants($account, $op) {
  $return = array('content_access_rid' => array_keys($account->roles));
  return $account->uid ? array('content_access_author' => array($account->uid)) + $return : $return;
}

/**
 * Implementation of hook_node_access_records()
 *
 * @param $optimize
 *   If the grants should be returned optimized.
 */
function content_access_node_access_records($node, $optimize = TRUE) {
  if (content_access_disabling()) {
    return;
  }

  // Apply per node settings if necessary.
  if (content_access_get_settings('per_node', $node->type)) {
    $grants = array();
    foreach (array('view', 'update', 'delete') as $op) {
      foreach (content_access_per_node_setting($op, $node) as $rid) {
        $grants[$rid]['grant_'. $op] = 1;
      }
    }
    foreach ($grants as $rid => $grant) {
      $grants[$rid] = content_access_proccess_grant($grant, $rid, $node);
    }
  }
  else {
    // Apply the content type defaults.
    $grants = content_access_get_default_grant($node);
  }

  if (empty($grants)) {
    // This means we grant no access.
    $grants[] = array('grant_view' => 0, 'grant_update' => 0, 'grant_delete' => 0, 'realm' => 'content_access_rid', 'gid' => 0);
  }
  else if ($optimize) {
    content_access_optimize_grants($grants, $node);
  }
  return $grants;
}

/**
 * Implementation of hook_nodeapi().
 */
function content_access_nodeapi($node, $op, $teaser, $page) {
  if ($op == 'delete') {
    db_query("DELETE FROM {content_access} WHERE nid = %d", $node->nid);
  }
}

/**
 * Implementation of hook_enable().
 */
function content_access_enable() {
  node_access_rebuild();
}

/**
 * Used by the ACL module.
 */
function content_access_enabled() {
  return !content_access_disabling();
}

/**
 * Implementation of hook_disable().
 */
function content_access_disable() {
  content_access_disabling(TRUE);
  node_access_rebuild();
}

/**
 * Remembers if we have disabled access.
 */
function content_access_disabling($set = NULL) {
  static $disabling = FALSE;

  if (isset($set)) {
    $disabling = $set;
  }
  return $disabling;
}

/**
 * Returns the content_access' settings.
 *
 * @param $return
 *   One of the content_access_available_settings(), e.g. 'view' or 'per_node'.
 * @param $type
 *   If not all, return the setting for the specified type.
 */
function content_access_get_settings($return = 'all', $type = NULL) {
  if ($return == 'all') {
    return variable_get('content_access_settings', array());
  }
  if (isset($type)) {
    $settings = content_access_get_settings($return);
    return isset($settings[$type]) ? $settings[$type] : content_access_get_setting_defaults($return, $type);
  }
  if (!isset($type)) {
    $settings = content_access_get_settings();
    return isset($settings[$return]) ? $settings[$return] : array();
  }
  return array();
}

/**
 * Saves the content_access settings - needs the complete settings array.
 */
function content_access_set_settings($settings) {
  // Cleanup the settings before saving.
  foreach (content_access_available_settings() as $setting) {
    if (isset($settings[$setting])) {
      foreach ($settings[$setting] as $type => $value) {
        if (!isset($value)) {
          unset($settings[$setting][$type]);
        }
      }
    }
  }
  variable_set('content_access_settings', $settings);
}

/*
 * Return an array containing all available content_access settings.
 */
function content_access_available_settings() {
  return array('view', 'update', 'delete', 'view_own', 'update_own', 'delete_own', 'per_node', 'priority');
}

/**
 * Defines default values for settings.
 */
function content_access_get_setting_defaults($setting, $type) {
  switch ($setting) {
    default:
      return array();
    case 'view':
    case 'view_own':
      return array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID);
    case 'update':
    case 'update_own':
    case 'delete':
    case 'delete_own':
      return content_access_get_permission_access(content_access_get_permission_by_op($setting, $type));
    case 'priority':
      return 0;
  }
}

/**
 * Returns an array of role ids, that contain the given permission.
 */
function content_access_get_permission_access($perm) {
  static $roles = array();

  if (!isset($roles[$perm])) {
    $roles[$perm] = array_keys(user_roles(0, $perm));
  }
  return $roles[$perm];
}

/**
 * Gets the name of a permission for the given operation, if there is a suiting one.
 */
function content_access_get_permission_by_op($op, $type) {
  switch ($op) {
    default:
      return FALSE;
    case 'update':
      return 'edit any '. $type .' content';
    case 'update_own':
      return 'edit own '. $type .' content';
    case 'delete':
      return 'delete any '. $type .' content';
    case 'delete_own':
      return 'delete own '. $type .' content';
  }
}

/**
 * Returns the default grants for a given node type.
 */
function content_access_get_default_grant($node) {
  // Cache per type default grants in a static array
  static $defaults = array();

  if (!isset($defaults[$node->type])) {
    $grants = array();
    $roles = user_roles();

    // Only process the 'view' op as node_access() will take care of edit and delete
    foreach (content_access_get_settings('view', $node->type) as $rid) {
      $grants[$rid]['grant_view'] = 1;
    }
    foreach ($grants as $rid => $grant) {
      $grants[$rid] = content_access_proccess_grant($grant, $rid, $node);
    }
    $defaults[$node->type] = $grants;
  }
  // We might have to update the author uid before returning the grants
  elseif (isset($defaults[$node->type]['author'])) {
    $defaults[$node->type]['author']['gid'] = $node->uid;
  }

  return $defaults[$node->type];
}

/**
 * Process a grant, which means add priority, realm and other properties.
 */
function content_access_proccess_grant($grant, $rid, $node) {
  $grant += array('grant_view' => 0, 'grant_update' => 0, 'grant_delete' => 0);
  $grant['realm'] = ($rid == 'author') ? 'content_access_author' : 'content_access_rid';
  $grant['gid'] = ($rid == 'author') ? $node->uid : $rid;
  $grant['priority'] = content_access_get_settings('priority', $node->type);
  return $grant;
}


/**
 * Returns the per node role settings. If no per node settings are available, it will return the
 * default settings.
 *
 * @param $op
 *   One of view, update or delete.
 * @param $node
 *   The node object.
 * @param $settings
 *    Optional array used to update the settings cache with the given settings.
 * @return
 *   An array of role ids which have access.
 */
function content_access_per_node_setting($op, $node, $settings = NULL) {
  static $grants = array();

  if (isset($settings)) {
    // Update settings cache
    $grants[$node->nid] = $settings;
    return;
  }
  if (!isset($grants[$node->nid])) {
    $grants[$node->nid] = content_access_get_per_node_settings($node);
  }
  // Apply the defaults if no per node settings are available
  return isset($grants[$node->nid][$op]) ? $grants[$node->nid][$op] : content_access_get_settings($op, $node->type);
}

/**
 * Saves custom per node settings in the own content_access table.
 */
function content_access_save_per_node_settings($node, $settings) {
  db_query("UPDATE {content_access} SET settings = '%s' WHERE nid = %d", serialize($settings), $node->nid);
  if (!db_affected_rows()) {
    db_query("INSERT INTO {content_access} (nid, settings) VALUES(%d, '%s')", $node->nid, serialize($settings));
  }
  // Make content_access_per_node_setting() use the new settings
  content_access_per_node_setting(NULL, $node, $settings);
}

/**
 * Gets the per node settings of a node.
 *
 * @note
 *   This function won't apply defaults, so if there are no other settings
 *   it will return an empty array.
 */
function content_access_get_per_node_settings($node) {
  $settings = db_result(db_query("SELECT settings FROM {content_access} WHERE nid = %d", $node->nid));
  if (!$settings) {
    return array();
  }
  return unserialize($settings);
}

/**
 * Removes grants that doesn't change anything.
 *
 * @note
 *   The grants are compared with the normal access control settings.
 */
function content_access_optimize_grants(&$grants, $node) {
  // Populate $view, $update and $delete with roles, that have access
  foreach (array('view', 'update', 'delete') as $op) {
    $$op = array();
  }
  foreach ($grants as $key => $grant) {
    foreach (array('view', 'update', 'delete') as $op) {
      if (isset($grant['grant_'. $op]) && $grant['grant_'. $op]) {
        ${$op}[] = $key;
      }
    }
  }
  // Compare the permissions.
  $all = array(DRUPAL_ANONYMOUS_RID, DRUPAL_AUTHENTICATED_RID);
  if (count(array_diff($all, $view)) == 0) {
    //grant view access to all instead of single roles
    $view = array('all');
    $grants['all'] = array('realm' => 'all', 'gid' => 0, 'grant_view' => 1, 'grant_update' => 0, 'grant_delete' => 0, 'priority' => content_access_get_settings('priority', $node->type));
  }
  $edit_perm_roles = content_access_get_permission_access('edit '. $node->type .' content');
  $edit_own_roles = content_access_get_permission_access('edit own '. $node->type .' content');
  if (in_array(DRUPAL_AUTHENTICATED_RID, $edit_own_roles)) {
    $edit_perm_roles[] = 'author';
  }
  foreach (array('update', 'delete') as $op) {
    $$op = array_diff($$op, $edit_perm_roles);
  }
  // $view, $update and $delete contain now only the necessary rids/author
  // so let's remove unnecessary grants, if any.
  foreach ($grants as $key => $grant) {
    foreach (array('view', 'update', 'delete') as $op) {
      if (isset($grant['grant_'. $op]) && $grant['grant_'. $op] && in_array($key, $$op)) {
        // It's still here, so we can't remove this grant
        continue 2;
      }
    }
    //ok, remove it
    $grants[$key] = FALSE;
  }
}

/**
 * Implementation of hook_node_type():
 * Update settings on node type name change.
 */
function content_access_node_type($op, $info) {
  switch ($op) {
    case 'delete':
      $settings = content_access_get_settings();
      foreach (content_access_available_settings() as $setting) {
        unset($settings[$setting][$info->type]);
      }
      content_access_set_settings($settings);
      break;
    case 'update':
      if (!empty($info->old_type) && $info->old_type != $info->type) {
        $settings = content_access_get_settings();
        foreach (content_access_available_settings() as $setting) {
          $settings[$setting][$info->type] = $settings[$setting][$info->old_type];
          unset($settings[$setting][$info->old_type]);
        }
        content_access_set_settings($settings);
      }
      break;
  }
}

/**
 * Implementation of hook_node_access_explain
 */
function content_access_node_access_explain($row) {
  static $interpretations = array();
  switch ($row->realm) {
    case 'content_access_author':
      $interpretations[$row->gid] = t('Content access: author of the content can access');
      break;
    case 'content_access_rid':
      $roles = user_roles();
      $interpretations[$row->gid] = t('Content access: ') . $roles[$row->gid] . t(' can access');
      break;
  }
  if (isset($interpretations[$row->gid])) {
    return $interpretations[$row->gid];
  }
}
